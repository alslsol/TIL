# 3. 파이썬

하위 작업: 3.1 핵심 (https://www.notion.so/3-1-19ff558bed6180968093f9a00b4fae6e?pvs=21)
생성 일시: 2025년 2월 13일 오전 9:32
최종 편집 일시: 2025년 2월 20일 오후 3:37

# 1. 변수

```jsx
var_name = value #변수명에 특정 값을 입력한단 것 의미
```

- 변수명은 뭐든 사용O
    - 다만 영어, 숫자, _만 이용할 것
    - 키워드는 불가능
- **개념 원리**: 객체라는 상자가 있음 >> 이 상자의 이름을 a라고 할 때 >> a에 1이라는 값을 부여하는 것
- 파이썬: 컴파일/링크 단계 생략 가능한 인터프리터 언어 >> 대화형으로 사용 가능
- 컴파일: 자연어를 컴퓨터가 이해 가능한 언어로 전환/번역하는 작업 >> 통번역하는 방식
    - 이를 생략하니 파이썬은 빠르게 작업 가능한 것 >> 파일은 줄마다 실시간 번역
    - 대신 파이썬은 개발 시간은 빨라도, 실행 시간은 느림 >> C/Java: 개발 시간 길지만, 실행 시간 빠름

```jsx
a = 1 #1이라는 값을 변수a에 담은 것
print(a)

#파이썬의 기본명사인 '키워드'는 변수명X
import keyword
keyword.kwlist

#단어 띄어쓰기X >> 언더바로 연결하기
seoul_dust_rate = 150
print(seoul_dust_rate)
```

## 1.1 number

- 파이썬: 상자(객체) 만들면 숫자든 문자든 뭐든 넣을 수 있음
    - 이외 언어: `int a` 등 숫자만 넣을 수 있는 객체 등 별도로 있음
- int: 정수
- float: 실수
- complex: 복소수

```jsx
a = 100
b = 1.1
c = 1 + 1j #j: 복소수 >> 실수보다 넓은 개념

print(a)
print(b)
print(c)

print(type(a)) >> int: 정수
print(type(b)) #float: 실수
print(type(c)) # 복소수(complex)
```

- `type(변수명)`: 변수의 유형을 알려주는 함수

## 1.2 boolean: T/F

```python
a = True #대문자로 적어야 함
b = False
print(type(a))
print(type(b))
```

## 1.3 string(문자열)

- `'`, `"` 이용해 표현

```jsx
#특정 단어 강조할 때, 문자열과 강조하려는 단어 서로 다른 기호 써야 함
print("hello my name is 'sori'")
```

### string interpolation: 문자열 사이에 변수 넣기

- %-formatting

```jsx
print('홍길동은 %s살입니다.' % age)
```

- str.format( )

```jsx
print('홍길동은 {}살 입니다.' .format(age))
```

- f-string

```jsx
print(f'홍길동은 {age}살 입니다.')
```

---

# 2. 연산자

## 2.1 산술 연산자

- `+` 더하기
- `-` 빼기
- `*` 곱셈
- `/` 나눗셈
- `**` 제곱
- `//` 몫
- `%` 나머지
- `divmod( )`: (몫, 나머지) 데이터 세트 도출하는 함수

```jsx
a = 10
b = 3
result = divmod(a, b)
print(result)
> (3, 1)
```

## 2.2 비교 연산자

- `>` `<`: 초과/미만
- `≥` `≤`: 이상/이하
- `==`: 동일 값인지
- `!=`: 다른 값인지

## 2.3 논리 연산자

- `and`: 양쪽 모두 T면, `True` 반환
- **`or`**: 하나라도 T면 `True` 반환, 모두 F면 `False` 반환
- **`not`**: 상태를 부정하는 역할

## 2.4 복합 연산자

- `a += b` == `a = a + b`
- `a -= b` == `a = a - b`
- `a *= b` == `a = a * b`
- `a /+ b` == `a = a / b`

## 2.5 기타 연산자

- **연결(concatenation)**
    - 문자열/리스트: `+`: 산술 연산자X → 문자열 연결해줌
- `in`: 데이터 리스트에 입력한 데이터가 있는지 확인
    - 예시: 숫자 1이 리스트 a에 포함돼 있는지
- `is`: 동일한 객체인지 확인
    - 데이터 내용 같아도, 메모리 상 저장 위치 다를 수 있음 → `is`는 근본적으로 동일한지 확인해줌
    - 파이썬: 256까지는 저장 위치 동일하도록 미리 지정해둠 → 더 큰 수는 `is` 해도 False 나옴

## 2.6 연산자 우선순위

1. ( )로 그룹화된 경우
2. `**`(제곱)
3. 산술 연산자(`*`, `/`)
4. 산술 연산자(`+`, `-`)
5. 비교 연산자, `in`, `is` 
6. `not` 
7. `and` 
8. `or`

# 3. 형변환

## 3.1 암시적 형변환

- 파이썬에서 자동으로 해주는 형변환

```jsx
a = True
b = False
c= 1

print(a + b) # T=1(전기 흐름), F=0(전기 안 흐름) >> 이렇게 자동으로 인식해 계산한 것
print(a + c)

if 1:
    print('hello') # 1=True로 자동으로 파이썬이 인식해서 값 도출한 것
```

## 3.2 명시적 형변환

- `int( )`: 괄호 안 숫자를 정수로 변환
- `float( )`: 실수로 변환
- `str( )`: 숫자로 변환
- `bool( )`: 분리형으로 변환

---

# 4. 시퀀스 자료형

- **시퀀스**: 데이터의 **순서대로** 나열된 자료구조
    - 순서대로 나열됐다 ≠ 정렬됐다
    - 자료 구조: 자료 묶여 있는 것 의미
- **선언**: 소괄호 | **접근**: 대괄호

## 4.1. [List]

- 시퀸스 중 유일하게 수정 가능(mutable) → index 통해 세부적으로 조정 가능
- 선언 방법: `var_name = [value1, value2, value3…]`
    - 리스트 내, 여러 데이터 타입 들어갈 수 있음 >> 리스트도 가능
- 접근 방법: `var_name[index]`
    - `index`: 순서 확인 위해 숫자/정수 데이터 사용 → index는 0부터 시작함
    
    ```jsx
    location = ['seoul', 'busan', 'incheon']
    print(location) # list 내 모든 데이터 출력
    print(location[0]) #파이썬은 0부터 시작하므로, 첫 번째 데이터만 출력
    
    > ['seoul', 'busan', 'incheon'] # 리스트는 대괄호로 출력됨
    
    location[1] = 'deogu' # 다른 데이터로 교체
    print(location)
    ```
    

## 4.2. (Tuple)

- **선언**: `var_name = (value1, value2…)`
- **접근**: `var_name = [index]`
- **특징:** 수정 불가능함(immutable)
    
    변수를 새 값으로 덮어 씌우기는 가능하나 >> index 통해 일부 범위만 수정X
    
    변수값 편하게 바꿀 때 사용
    
- 예시

```jsx
location = ('seoul', 'busan', 'incheon')
print(location)
> ('seoul', 'busan', 'incheon') # 튜플은 소괄호로 출력됨
```

## 4.3. Range( )

- range(n): 0 ~ n-1 범위 의미
- range(n, m): n ~ m-1 범위 의미
- range(n, m, s(간격)): n ~ m-1 까지, s만큼 증가하는 범위

```jsx
lotto = range(45)
print(lotto)
print(list(lotto)) # lotto 속에 어떤 데이터 있는지 모두 보여줌 >> 0부터 44까지 있음

# 1부터 45까지의 숫자를 저장하고 싶다면?
lotto = range(1, 46)
print(lotto)
print(list(lotto))
```

```jsx
even = range(2, 20, 2) # 2~19 숫자 중 2씩 증가한 범위만 포함 >> 그래서 2~18까지 짝수만 출력됨
print(list(even))

numbers = range(0, -20, -2) # -19~0 숫자 중 -2씩 감소한 범위만 포함 >> -18~0까지 짝수만 출력
print(list(numbers))
```

## 4.5 시퀀스에서 활용 가능한 연산/함수

- **indexing**: 단일 데이터에 접근하는 방법
    - `var_name[index]` s

```jsx
my_list = ['a', 'b', 'c', 'd', 'e']
print(my_list[0])
# 0번째 데이터 'a' 출력됨
```

- **slicing**: 일정 범위 데이터에 접근하는 방법
    - `var_name[index1:index2]`

```jsx
my_string = '가나다라마'
print(my_string[0:2])
#0번째부터 1번째까지의 데이터 출력됨 >> '가나' 출력
```

- `[n:]`: n ~ 맨 끝까지 출력
    - `[:n]`: 맨 앞 ~ n까지 출력
- `- [index]`: 뒤에서 숫자 세기
    - 맨 뒤 index: -1

```python
print(my_list[-1]) # 뒤에서 1번째 데이터 출력
print(my_list[-3:-1]) # 뒤에서 1~2번째까지 출력
my_list[::-1] # 리스트 배열 뒤집기
```

- `step`: 특정 간격 만큼만 출력할 때

```python
print(my_list[::2]) # 맨 앞부터 2칸씩 증가한 범위만 출력
```

- `in` / `not in`
    - `in`: 시퀸스 내에 해당 데이터 있는지 T/F
    - `not in`: 시퀸스 내에 해당 데이터 없는지 T/F

```python
print(1 in my_list) # my_list에 1 있는지
print(1 not in my_list) # my_list에 1 없는지
```

- comcatennation(연결)
    - 시퀸스형 자료는 전부 연결 가능
    - 동일 자료형만 연결 가능 → list+list (O), list+tuple(X)

```python
print(my_list + [1, 2, 3, 4, 5]) # 리스트 2개 연결한 것
```

- *(곱셈): 연결 반복 의미

```python
print(my_list * 2)
print('가' * 5)
print([0] * 10) # 0 들어있는 리스트를 10번 연결
```

---

# 5. 이외 자료구조

- 시퀀스: 순서O ↔ 비시퀸스: 순서X, 집합임
- 수정 가능함(meutable)

### 5.1 {Set}

- **선언**: `var_name = {value1, value2 ...}`

```jsx
my_set_a = {1, 2, 3, 4, 5}
print(my_set_a)
```

- ‘집합’과 비슷한 개념
    
    차집합: my_set_a - my_set_b
    
    합집합: my_set_a | my_set_b
    
    교집합: my_set_a & my_set_b
    
    - set만 집합 적용 가능 → 두 list 간 교집합 구할 시, set로 형변환 필요
- 중복값X → 중복 데이터 있을 시 제거해줌
    - 순서 없어 집합 이용해 연산할 때 유의미 → 그래서 단일 데이터 접근하는 접근법X

```jsx
location = ['서울', '대구', '대구', '부산', '서울', '대구', '부산']
print(set(location))
> {'대구', '부산', '서울'} # 중복값 제거해줌
```

## 5.2 {Dict: ionary}(사전)

- **선언**: `var_name = {key1: value1, key2: value2, ...}`
    - `key: value`가 한 세트임
        - `key`: 찾고 싶은 단어
        - `value`: 찾은 단어의 의미 >> 키의 값
- 접근: `var_name[key]`
- key(item_name) 기준으로만 접근 가능
    - 사전도 의미 기준으로 단어 찾으려면 찾기 힘들듯

```jsx
my_dict = {'서울': '02', '경기': '031'}
print(my_dict['서울'])
> 02 출력됨
```

```jsx
my_info = {
    'name': 'sori',
    'location': 'seoul',
    'age': 25,
    'skill': ['python', 'git']}
# 리스트는 동일한 자료형을 입력하는 것을 가정, dirctionary는 서로 다른 자료형 입력 가능, 사전 안에 사전 넣을 수도 있음
print(my_info['name']) # dict의 name이라는 키의 value만 출력
```

- dict 속 list의 특정 범위만 출력할 때
    - `print(dict_name[list_name][index])`: list 내에 다시 괄호X, 옆에 별도로 대괄호 빼야 함

```jsx
print(my_info['skill'][1])
```

---

# 6. 제어문

## 6.1 if문

- i반드시 T/F 판단 가능한 ‘조건식’과 함께 사용
- 명령어 구조

```python
if <조건식>:
		조건식 True일 때 실행하는 코드
else:
		조건식 False일 때 실행하는 코드
```

- 예시1

```python
my_string = input() # input(): 실행한 뒤 나온 값을 my_string 변수에 저장하는 것 >> run하면 하단에 창 뜸 / input은 사용자가 직접 박스에 입력할 수 있게 하는 역할
print(my_string) # 출력하면, 내가 입력한 것이 출력되도록 됨

if my_string == '12/25':
    print('merry christmas!')
else:
    print('NO')
# my_string 값이 '12/25'이 맞는지 묻는 것
# 창에 12/25일 입력하면, 조건문 참이기에 '메리 크리스마스' 문구 출력됨
```

- 예시2

```jsx
num = int(input()) #input함수 실행된 다음 >> 받은 값을 int(숫자)로 변환 >> 그 결과를 num 변수에 저장한단 것

if num % 2 == 1:
    print('홀수')
else:
    print('짝수')
```

- 간략한 코드
    - `num % 2` = 0 or 1 나옴
        - 파이썬: `0 == F`, `1 == T` 자동 인식함
    - 이를 활용해 코드 압축 가능

```jsx
num = int(input())

if num % 2:
    print('홀수')
else:
    print('짝수')
```

### elif

- 명령문 구조

```python
if <조건식>:
		if문이 참인 경우 # 1번째 조건 T/F
elif <조건식>:
		elif문이 참인 경우 # 2번째 조건 T/F 묻기
else:
		모든 조건식이 거짓인 경우
```

- 예시

```jsx
score = int(input())

if score >= 90:
    print('A')
    if score >= 95:
        print('참 잘했어요') # 90점 이상 중, 95점 이상의 경우 출력하도록 하는 것 >> if문 내 if문 들여쓰기 통해 넣을 수 있음
elif score >= 80:
    print('B')
elif score >= 70:
    print('C')
else:
    print('F') # 70점 미만의 경우 모두 F 출력
```

### 조건표현식

- T/F에 따라 값 달라질 때 사용
- **구조**: `true_value if <조건식> else false_value`
- 예시: 음수면 0, 양수면 num 그대로 출력

```jsx
#일반적인 조건문
num = int(input())

if num >= 0:
    result = num
else:
    result = 0
print(result)

#조건표현식
num = int(input())
result = num if num >= 0 else 0 
```

---

## 6.2 반복문

### while 문

- **구조**: 참이면 코드 실행, 거짓이면 실행 중단

```jsx
while <조건식>:
		실행할 코드
```

- 무한 루프 빠지지 않게 >> 종료 시점 정해줘야 함
- 예시
    - 조건문 `a < 5` 참이면: a 출력 → a = a + 1 실행 → a값 증가해질 것
        - `a = a + 1` == `a += 1`
    - 조건문 `a < 5` 거짓이면: while문 종료

```jsx
while a < 5: 
    print(a)
    a += 1
```

### for문

- 정해진 범위 내의 반복할 때 사용
    - 정해진 범위 = 시퀀스의 범위 의미 → 시퀀스 순서대로 반복하는 것
- 구조
    - `variable_item`: 시퀸스 범위 내 개별 아이템 담기 위한 공간

```jsx
for variable_item in sequence_name:
		실행할 코드
```

- 예시
    - number 하나씩 불러서 코드 실행 → 출력 결과도 하나씩 나옴

```jsx
numbers = [1, 2, 3]

for number in numbers: # number: 각 아이템 하나 의미
    print(number)
> 1
	2
	3
```

- 예시: string → 알파벳 분리해 출력

```jsx
word = 'sori'

for char in word:
    print(char)
> s
	o
	r
	i
```

- 예시: range( )
    - 0~2까지 i에 할당해 출력

```jsx
for i in range(3):
    print(i)
> 0,
	1,
	2
```

- 예시: if + for문
    - 10~20 중, 5의 배수만 출력

```jsx
number = range(10, 21)

for num in number:
    if num % 5 == 0:
        print(num)
> 10
	15
	20
```

- `enumerate( )`: 각 데이터는 몇 번째 데이터인지 정보 같이 출력해줌

```jsx
# enumerate( ) 활용
locations = ['서울', '대전', '부산']
for location in enumerate(locations):
    print(location)
> (0, '서울') # 출력값 소괄호 >> tuple이란 것
	(1, '대전')
	(2, '부산')

# tuple 분리하기
for (index, location) in enumerate(locations):
    print(index)
    print(location)
> 0
	서울
-> 이런 식으로 나눠주는 방식도 있음
```

- **dictionary 반복**
    - key: 변수 → ex. name, location, age
    - value: 변수에 할당된 값 → ex. sori, seoul, 20
    - key, value 중 무엇이 필요한지 따라 사용하는 명령문 다름

```jsx
info = {'name': 'sori',
'location': 'seoul',
'age': 20}
```

- key 반복: `for (item) in dict`

```jsx
for k in info:
    print(k)
```

- value 반복: `for (item) in dict.values( )`

```jsx
for v in info.values(): #밸류를 반복해 출력해줌
    print(v)
```

- 둘 다 반복: `for (key_item, value_item) in dict.item( )`

```jsx
for k, v in info.items(): # 키, 밸류 모두 반복해 출력해줌
    print(k, v)
```

- 예제:

```jsx
bloods = {'A': 15, 'B': 8, 'o': 3, 'AB': 9}

for k, v in bloods.items():
    print(f'{k}형은 총 {v}명 입니다.')
    
> A형은 총 15명 입니다.
	B형은 총 8명 입니다.
	o형은 총 3명 입니다.
	AB형은 총 9명 입니다.
```

## 6.3 키워드

### break

- 자신과 가장 가까운 반복문 종료시키는 키워드 → 완전 종료할 때 사용
- 예시: 조건문 참일 때 while문 종료하는 경우

```jsx
while True: # true를 넣어놨으니, 이 코드는 일단 무한히 돌 것
    rice = input() # 코드 계속 돌아가는데 사용자에게 입력값 받음
    if rice == '쌀': #근데 쌀 입력하면
        print('잡았다!') #잡았다 출력한 뒤
        break #while문 종료됨
```

### continue

- continue 이후 코드 스킵, 다음 반복으로 넘어감 → 특정 값 스킵할 때 사용
    - 홀수라면 스킵 → 짝수만 출력

```jsx
for i in range(20):
    if i % 2 == 1:
        continue
    print(i)
```

### else

- 끝까지 반복된 경우 실행됨 → break 만나지 않는 경우 실행
- 예시
    - 조건문 참: i > 100이면 break
        
        조건문 거짓: ‘모두완료!’ 출력
        
    - 근데 범위: 0~9 → 따라서 break 만나지X아 끝까지 실행돼 else 코드실행

```jsx
for i in range(10):
    if i > 100:
        break
    print(i)
else:
    print('모두완료!')
```

---

# 7. 함수

- 정보 입력해 일 시키면 그 결과로 산출물 나옴 → 그러한 일련의 단위
    - 코드의 재사용성을 높이기 위해 만드는 것 → 일일이 코드 만들면 비효율적
- 예제: 사각형의 가로/세로 길이 이용해 면적/둗레 구하는 코드

```jsx
height = 50
width = 20

area = height * width # 면적 공식
perimeter = (height + width) * 2 # 둘레 공식
print(f'사각형의 면적은 {area}이고, 둘레는 {perimeter}입니다.')
```

## 7.1 함수의 선언과 호출

- **선언**
    - `def`: 다음 함수를 정의한다는 명령어 → 함수 정의한 거라 작동X, 호출해야 작동O
        - parameter: 함수 실행하기 위해 데이터가 들어가는 공간 → like 매개변수

```python
def func_name(parameter1, parameter2, ...):
		code1
		code2
		return value
```

- **호출**
    - 소괄호 열림 == 함수 호출됐단 의미

```python
func_name(parameter1, parameter2, ...)
```

- 예제: 사각형 둘레/면적 구하는 함수 만들기
    - 한번 함수 선언하면, 간단히 계속해 해당 함수 호출 가능

```python
# 선언
def rectanle(height, width):
    area = height * width
    perimeter = (height + width) * 2
    print(f'사각형의 면적은 {area}이고, 둘레는 {perimeter}입니다.')

# 호출
rectanle(50, 30)
```

- 예제: `max( )`와 동일한 기능하는 함수 만들기
    - `max( )`: parameter 중 큰 것을 뽑아주는 기능

```python
def my_max(num1, num2): # 데이터 2개 받을 거라고 정의
    if num1 > num2:
        print(num1)
    else:
        print(num2)
my_max(100, 2)
```

## 7.1.1 함수의 return

- 함수 결과값 반환해줌: 함수가 `reutrn` 만나면 해당 값 반환/종료함 → 결과를 지정하는 역할
- 예제:
    - return 하면 임무 완수했다고 여김 → 함수는 연산 종료, 근데 반복문 돌아가므로 3 반복한 것

```python
def my_for(x):
    for i in range(x):
        print(i)
        if i == 3:
            return i
my_for(5)
> 1
	2
	3
	3
	3
```

- `break`도 할 일 끝나면 반복문 종료하듯 → `return`도 임무 완수하면 종료
- 만약 `return` 없을 시, 자동으로 None 반환
    - print ↔ return 차이점:
        - print: 함수 연산 결과를 산출한 게X, 입력값을 출력한 것
            
            → 출력값 재사용X, 재사용 시 None 반환
            
        - 0 ↔ null: 0: 0이라는 데이터 있는 것 | null: 데이터 자체가 없단 것
        - return: 함수 연산 결과를 산출 → 연산 결과 저장해 이후 또다른 연산할 때 재사용O
    - 예제: 큰 수를 구한 다음, 큰 수에 2 곱하기
    
    ```python
    def my_max2(num1, num2):
        if num1 > num2:
            return num1 # num1이 더 크면 결과값 num1을 반환한단 것
            return num2
    my_max2(1, 3)
    
    result = my_max2(1, 3) * 2
    print(result)
    ```
    
- `return`은 하나의 객체만 반환 → 함수기 때문에 각 변수엔 결과 1개만 저장O
    - return( ): 여러 개 객체 입력하면, 튜플로 전환됨
    - 예제:  (출력값, 입력값)으로 묶이는 tuple 방식으로 return 값 출력하기
        - 소괄호로 묶으면 튜플로 전환돼 여러 객체 저장 가능

```python
def my_def(x):
    return (x * 2, x)
my_def(10)
```

- 예제: 두 list 총합 구한 뒤, 큰 list 출력하기
    - for문 활용한 경우
    
    ```python
    def my_list_max(list1, list2):
        # 각 리스트의 총합 구하기
        sum_of_list1 = 0 # 누적합 구하기 전에, 초기값 0을 설정
        sum_of_list2 = 0
    
        # 리스트1의 데이터 하나씩 호출해서 sum_of_list1에 할당하는 식으로 할 것 >> 데이터 누적해 총합 구하는 방식
        for i in list1:
            sum_of_list1 = sum_of_list1 + i
        for i in list2:
            sum_of_list2 += i # 위의 식과 동일한 내용임 >> 코드 압축한 것
    
        # 두 총합을 비교하기 / 더 큰 값의 리스트를 출력하기
        if sum_of_list1 > sum_of_list2:
            return list1
        else:
            return list2
    ```
    

- sum( ) 함수를 활용한 경우

```python
def my_list_max(list1, list2):
        result1 = sum(list1)
        result2 = sum(list2)
        if result1 > result2:
            return list1
        else:
            return list2
```

## 7.2 함수의 인수

### 위치인수

- 함수는 위치를 기준으로 인수 판단함
    - 예제: 원기둥 부피 구하기
        - 공식: 3.14 * r(반지름) ** 2 * h(높이)
        - 첫번째 데이터는 r에 들어감, 두번째 데이터는 h에 들어감
    
    ```python
    def cylinder(r, h):
        return 3.14 * r ** 2 * h
    ```
    

### **기본값**

- 사용자에게 정보 받을지 말지 선택하게 하는 역할함
    - 여러 파라미터 중 일부만 기본값 설정한다면: 기본값 없는 인자부터 입력토록 해야 함
- 구조

```python
def func_name(p1=v1):
    code1
    return value
```

- 예제: 함수 호출 시, 인자 입력X도 기본값 '익명' 출력하기

```python
def greeting(age, name='익명'):
    return f'{name}님의 나이는 {age}살 입니다.'
greeting(25, '소리')
```

### 키워드 인수

- 함수를 호출할 때 내가 원하는 위치에 직접 값 전달
    - 예시

```python
greeting(name='소리', age=25)
```

### 가변 인자 리스트:

- 변할 수 있는 인자 → 데이터 몇 개 받을지 지정X고 `params`(묶음)으로 처리해 받는 것
    - 일반적 함수: 지정한 파라미터 갯수만큼 입력받을 수 있음 → 안 그러면 에러
        - 근데 print( ): 인자 몇 개든 가능
- 구조

```python
def func_name(*params):
		code
		return value
```

- 예제: 데이터 리스트 가장 큰 수 출력하기

```python
def my_max(*nums):
    max_num = nums[0] # 입력된 데이터 중 첫 번째 데이터를 초기값으로 지정한 것

    for i in nums:
        if i > max_num:
            max_num = i
    return max_num

my_max(1,2,3,4,5,6,7)
```

### 정의되지 않은 키워드 인자 처리

- 구조

```python
def func_name(**kwargs):
		return value
```

- dict() 함수: name, age라는 각 위치 인자 지정되지 않았는데 작동함
    - 정의되지 않은 키워드 인자를 처리하도록 자동으로 설정돼 있기 때문

 # 내부적으로 어떤 파라미터 들어오든 이를 하나의 묶음으로 만들어 dictionary로 만들어줌, 리스트로 만들어주는 게 가변 인자 리스트, dict로 만들어주는 게 정의되지 않은 인자 처리 방식인 것

# dict 함수에는 키워드 형태의 파라미터 어떤 것이든 모두 넣을 수 있음

```python
info = dict(name = 'park', a1ge = 25)

def my_dict(**kwargs):
    print(kwargs)
my_dict(asdf = '가나다', age = 123, test = 'asdf')
```

- 여러 인자 복합해 함수 선언 가능: 위치인자, 가변인자 리스트, 정의되지 않은 키워드 인자
    - 예시

```python
def my_func(params1, params2, *numbers, **kwargs)
my_func(123, 234, 345, 456, a = 1, b = 2, c = 3) # kwargs = {a:1, b:2, c:3}으로 키워드 인자 들어간 식
```

## 7.3 lambda 표현식

- 임시적으로 쓰는 일회용 함수 → 따라서 이름 없는 익명 함수
    - 장점: 함수 이름 설정+ return 생략 가능→ 빠름, 효율적
        - lambda 함수는 이름 없는 함수라 이름 지정 않은 것
- 구조

```python
(lambda parameter: expression_연산식)()
```

- 예시

```python
(lambda num1, num2: num1 + num2)(1, 2)
```

## 7.4 타입힌트

- 타인이 작성한 코드 가져와 활용할 때, 객체에 어떤 데이터 넣는지 표시해주는 것(주석)
    - java, c언어 등: 어떠한 형태의 데이터 들어가는 객체인지 지정해 코드 작성
        - 코드 작성 오래 걸리나, 실행 속도 빠름, 실행 안정성 높음
    - 파이썬: 객체 지정할 때 어떤 형태 데이터 들어가는지 미리 설정X도 됨
        - 개발 속도 높으나, 실행 안정성 낮음
    - 예시
        - `(a: int, b: int)`: a, b 객체에 숫자를 넣어야 한다는 것 알려줌
        - `→ int`: 출력 값의 데이터 형태 알려주는 것
    
    ```python
    def something(a: int, b: int) -> int:
    		return a + b
    my_sum(1, 2)
    ```
    

## 7.5 이름 공간(namespace) / 스코프(scope)

### **이름 공간**

- python에서 사용하는 이름들은 이름 공간에 저장돼 있음
- 어떤 데이터 접근하기 위해 이름 만들어 놓음 → 호출 위해 저장해 놓은 것
- LEGB 룰에 따라 접근함: 가까운 곳 >> 먼 곳 순으로 이름 찾음
    - Local: 정의된 함수 내부
    - Enclosed: 상위 함수
    - Global: 함수 밖
    - Built-in: python이 기본적으로 가진 함수
- 예시:  같은 이름으로 여러 변수/함수 만들어질 수 있음
    - 근데 변수는 덮어쓰기 불가능 → LEGE 룰 따라 가까운 순으로 변수명 찾아 적용
    - str이라는 변수 만들어서 문자 데이터 저장한 것 >> 근데 그러면 에러 남
    - 여기에서는 바로 위에서 만들어진 str 변수를 local 위치에서 찾아서 적용한 것

```python
result = 123 # 123이라는 데이터를 result 변수에 담아 출력한 것
print(result)

result = str(123) # 숫자 123이 문자열로 변환돼 출력됨
print(result)
# 여기에서는 빌트인 함수인 str()를 활용한 것

str = 'hello'
```

- 예시: 함수 밖 → 안으로 들어가 이름 찾기 불가능

```python
a = 1 # a라는 이름 가진 상자에 숫자 1 넣음
def local_scope(a): # local_scope라는 함수 정의
    return a
a = '가나다라' # a = 1의 a가 '가나다라'로 바뀜: 함수 밖에서 안으로 접근X기 때문
local_scope('hello') # local_scope로 들어가, 가장 가까운 a에 'hello' 데이터 할당
```

- 예시: 로컬 바깥의 변수 a를 함수 내부로 가져와 연산할 때
    - `globla a` : 로컬X, 함수 외부의 글로벌 범위 탐색하라는 명령어

```python
a = 0
def global_scope():
    global a
    a = a + 1
    return a

global_scope()
```

## 7.6 재귀 함수

- 함수 내부에서 자기 자신을 호출하는 함수
    - like 내부의 내부의 내부…

```python
n! = 1 * 2 * 3 *...* n
	= (n-1)! * n
```

- 예제: 10! 구하기
    - 10! 구하려면 9! 필요, 9! 구하려면 8! 필요
        
        → 10! 연산 실행 중인 상태에서 아래의 1!부터 올라가며 연산 이뤄지는 방식
        
    - ex. fact(10  fact(9  fact8(…)))

```python
def fact(n):
    if n == 1:
        return 1
    else:
        return fact(n-1) * n
fact(10)
```

---

### 참고자료

[파이썬 자습서]([https://docs.python.org/ko/3.13/tutorial/index.html](https://docs.python.org/ko/3.13/tutorial/index.html))

### 프로그래머스 입문 문제

- 다음주까지 정답률 80% 대까지는 풀자, 70% 대는 좀 어려울 수 있음
- vs code에서 파이썬 코드 실행하는 방법

```python
$ cd 두수의곱/
$ python sol.py
```

---

# 8. 자료구조

- 여러 자료구조가 가진 메소드(함수) 알아보기
    
    
- `dir()`: 해당 데이터가 사용 가능한 기능을 알려줌

```python
print(dir('hello'))
> add, class, str ...
```

## 8.1 문자열 메소드

- 외우기 보단, 사용 시 검색해 활용
    
    
- `변수명.capitalize()`: 데이터의 시작 글자만 대문자로 전환
    - 데이터 자체를 바꾸는 건X, return 값만 전환해준 것 → 원본 데이터가 수정되는 건X
        - 문자열은 수정 불가능한 특성 가져서 원본 데이터는 유지됨

```python
a.capitalize()
```

- `변수명.title()`: 각 단어 첫 글자를 모두 대문자로 변경
- 변수명.lower(): 모든 단어를 소문자로 변경
- 변수명.upper(): 모든 단어를 대문자로 변경
- ‘기호’.join(): 작은 따옴표 안의 기호 등을 → 소괄호 안의 데이터와 결합
    - 예제
    
    ```python
    '?'.join('배고프다')
    > '배?고?프?다'
    ```
    
    - 예제: 여러 단어 쪼개져 있는데 하나의 문장으로 묶어 출력하고 싶다면
    
    ```python
    my_list = ['my', 'name', 'is', 'sori']
    ' '.join(my_list) # 각 단어 사이를 띄어쓰기 넣어 묶는 것
    > 'my name is sori'
    ```
    
- `변수명.strip()`: 띄어쓰기, \t(들여쓰기), \n(줄바꿈) 등 좌우 여백 삭제
    - `lstrip()`: 왼쪽에 있는 것만 지우기
    - `rstrip()`: 오른쪽에 있는 것만 지우기
    - 기본값으로 공백 삭제 기능O → 소괄호 안에 인자 넣지 않아도 공백 삭제됨
        - 소괄호 내 인자 설정할 시, 해당 인자 삭제 가능
    
    ```python
    a = '!!hello?'
    a.strip('!')
    > helllo?
    ```
    
- `str.replace(old, new, count)`: old 단어를 new 단어 지정해 변경 가능
    - count: 새로 몇 개를 바꿀지 지정하는 것
- `변수명.find()`: 변수 데이터 내 해당 글자가 몇 번째 인덱스에 있는지 출력
    - 동일 데이터 있다면 → 가장 첫 번째 데이터의 인덱스 출력
    - 출력 결과 `-1`: 해당 데이터 없단 것
- `변수명.index()`: 변수 내 해당 데이터 찾아 인덱스 출력
    - 찾는 데이터 없다면 에러나서 실행 종료
- `변수명.split(value)`: 띄어쓰기 기준으로 데이터 잘라, list로 묶어줌
    - 소괄호 내에 인자 설정 → 특정 인자 기준으로 데이터 잘라줌
- `변수명.count()`: 변수 내 해당 데이터 몇 개 있는지 세줌

## 8.2 리스트 메소드

- 리스트는 immutable(수정 가능함) → 원본 데이터도 수정됨
- `변수명.append(value)`: 맨 뒤에 데이터 추가
- `변수명.extend(value)`: 여러 데이터 추가 → 리스트 2개를 연결하는 방식
- `변수명.insert(index_num, value)'`: 특정 인덱스 위치에 데이터 추가
    - 예제
    
    ```python
    def solution(num_list):
        result = []
        for num in num_list:
            result.insert(0, num) # 0번째 자리에 추가하겠단 것
        return result
    print(solution([1, 2, 3, 4, 5]))
    ```
    
- `변수명.remove(value)`: 데이터 삭제 → 동일 데이터 여러 개면, 첫 번째만 삭제
- `변수명.pop()`: 맨 뒤 데이터 하나 삭제
    - `변수명.pop(0)`: 맨 앞 데이터 삭제
- `변수명.sort()`: 오름차순 정렬 → 원본 데이터 수정O
    - `변수명.sort(reverse = True)`: 내림차순 정렬
    - `sorted(변수명)`: 파이썬 빌트인 함수 → 오름차순 정렬
        - 계산 결과만 알려줌 → 원본 데이터 수정X
    - 문자열도 유니코드 기준으로 정렬해줌
- `변수명.reverse()`: 데이터 뒤집어 정렬 → 내림차순 정렬X, 뒤집기만O
- `변수명.count(value)`: 동일 데이터 갯수 세줌

### list copy

- 예시: origin_list도 바뀌게 됨: 이는 실제 데이터 값은 다른 공간에 저장돼 있고, 각 변수가 가진 게 아니어서 >> copy_list 변경 시, origin_list도 동시에 변경되는 것

```python
origin_list = [1,2,3]
copy_list = origin_list

copy_list[0] = 100

print(origin_list)
print(copy_list)
```

- 예제: 독립적인 카피 리스트 만들고 싶다면
    - [:] 처음부터 끝까지 슬라이싱 한다는 것 → copy_list 자체가 원본 데이터 전체 복사하게 됨
        - 근데 리스트 내 리스트 있는 경우는 복사X

```python
# 독립적인 카피 리스트 만들려 한다면
origin_list = [1,2,3]
copy_list = origin_list[:]

copy_list[0] = 100

print(origin_list)
print(copy_list)
```

```python
origin_list = [1,2, [10, 11]]
copy_list = origin_list[:]

copy_list[0] = 100
copy_list[2][0] = -10 # 두번째 리스트의 첫번째를 수정한단 것 >> 근데 두번째 리스트의 경우 슬라이싱 되지 않고, 이 경우 원본과 동일한 데이터 공간 공유

print(origin_list)
print(copy_list)
```

- 예제:  리스트 내 리스트 있을 때, 리스트 카피하기
    - import copy: copy라는 모듈(공구상자) 내 기능(도구) 활용하겠다는 것
    - copy.deepcopy(list_name): 리스트 내 리스트 있더라도, 데이터 복제 가능

```python
import copy
oring_list = [1, 2, [10, 11]]
copy_list = copy.deepcopy(origin_list) # 카피의 deepcopy라는 도구를 꺼내겠단 것
copy_list[0] = 100
copy_list[2][1] = -11

print(origin_list)
print(copy_list)
```

### list comprehension

- 예제: 리스트의 데이터를 3제곱 하기
    - list comprehension 활용 시:
        - for 문 이전: 연산 식 | for 문 이후: 무엇을 반복할지

```python
numbers = list(range(1, 11)) # 1부터 10까지의 데이터 리스트 만들기
print(numbers)

# 각 데이터를 3제곱 하고 싶다면

result = [] # 3제곱한 결과를 저장할 리스트 만듦

for number in numbers:
    temp = number ** 3 # 3제곱해서 임시 저장소에 저장
    result.append(temp) # temp에 저장된 데이터를 result에 하나씩 추가

print(result)

# list comprehension 활용하기
result = [number **3 for number in numbers]
print(result)
```

- 예제: 짝수만 고르기

```python
numbers = list(range(1, 31))
result = []

for number in numbers:
    if number % 2 == 0:
        result.append(number)
print(result)

#list comprehension 활용
result = [number for number in numbers if number % 2 == 0]
    # numbers 리스트 반복하는데, 2로 나눈 값이 0이면, number에 저장할 거란 것
print(result)
```

- 예제: 모음 제거하기

```python
# 1. for / if 활용: not in
word = 'my name is hong'
vowels = ['a', 'i', 'e', 'o', 'u'] # 문자열 'aeiou'도 시퀀스므로 이런 식으로 해도O
result = [] # word의 각 i를 반복한 값을 result에 저장하려는 것
for char in word:
    if char not in vowels:
        result.append(i)
print(''.join(result)) # 쪼개진 여러 단어를 하나의 문장으로 묶기

# 2. list comprehension 활용
result = [char for char in word if char not in vowels]
print(''.join(result))

# 3. replace 메소드 활용: 수정 후 원본 덮어쓰기
vowels = 'aeiou'
for char in vowels:
    word = word.replace(char, '') # char에 있는 정보를 ''(공란)로 변경
    # str 메소드는 원본 수정 안 됨 >> 그러니 원본 덮어쓰기
print(word)

```

## 8.3 dictionary 메소드

- `.update(항목명=value)`: 새로 값 할당

```python
info.update(name = 'sori')
```

- `.pop(key)`: 원하는 키와 값을 제거해줌

```python
info.pop('location')
```

- `.get(key)`: 해당 키의 값(value) 찾아줌 → dict에 없는 키 입력 시 none
    - info[key]: dict에 없는 키 입력 시 에러

```python
print(info.get('name'))
> sori
```

- 예제: 혈액형 구분하기 → key 정해진 상태에서 dict 접근

```python
blood_type = ['A', 'O', 'A', 'A', 'B', 'B', 'AB', 'O', 'O']

# 각 혈액형 몇명인지 dict 만들기
result = {'A': 0, 'B': 0, 'O': 0, 'AB': 0}

for blood in blood_type:
    result[blood] += 1 #A값 들어오면, result에 갯수 추가하려는 것
    # result[blood] = result[blood] + 1
print(result)

```

- 예제: 지역 구분하기 → key 정해지지 않은 상태에서 dict 접근

```python
locations = ['서울', '서울', '대전', '부산', '대구', 'LA', '파리']

result = {} # 키값 모르니 일단 비워둠

# 넣으려는 키가 현재 목록에 있는지 검사 >> 있으면 +1 하기, 없으면 새 지역 키 생성
for location in locations:
    if location in result.keys(): # location이 result 목록에 있는지 확인
    # if result.get(location) -> 이런 식으로 작성할 수도 있음
														    # result 목록에 for문 통해 입력된 location 있는지 확인
        result[location] += 1 # 기존 데이터에 있을 시 +1
    else:
        result[location] = 1 # 새 키 만들어 1이라는 값 할당
print(result)
```

### .3.1 dict comprehension

- 예제: {1: 1, 2: 8, 3: 27... 10: 1000} 형태의 dict 만들기

```python
# 1. for 문 활용
result = {}
numbers = range(1, 11)

for number in numbers: # result에 1-10까지 숫자 넣음
		# 앞서 넣은 숫자를 키값으로 설정 >> 연산값을 키의 밸류로 할당
    result[number] = number ** 3 
print(result)

# 2. dict comprehension 활용
# for 왼쪽에 연산 코드 작성: (key: value) 작성해줘야 함
result = {number: number ** 3 for number in range(1, 11)}
print(result)
```

- 예제: 미세먼지 농도 30 이하 지역만 고르기

```python
dust = {'서울': 50, '인천': 100, '수원': 30, '부산': 0}

# 1. for문
result = {}
for k, v in dust.items(): # dict에서 k, v 모두 출력해줌(cf. 파이썬 문법 dict)
    if v <= 30:
        result[k] = v
print(result)

# 2. comprehension
result = {k: v for k, v in dust.items() if v <= 30}
print(result)
```

## 8.4 set 메소드

- `.add(value)`: 데이터 추가
- `.update({value1, value2..})`: 여러 데이터 추가 → 2개 데이터 세트 연결하는 식
- `.remove(value)`: 데이터 제거
    - `.pop()`: 랜덤 데이터 제거 → 세트는 순서 없는 형태기 때문

## 8.5 기타 메소드: map, gilter, zip

- 특징: lazy한 연산으로 바로 연산X → 사용자가 list()로 묶어야 연산 이뤄짐

### map

- `map(함수, 시퀀스 데이터)`: 시퀀스 데이터에 일괄적으로 함수 적용
    - 함수 이름만 적으면 됨
    - 예제: numbers 리스트의 숫자를 일괄적으로 문자열로 바꾸기: ex. '1', '2'...

```python
numbers = [1,2,3,4,5]

# 1. for문
result = []
for num in numbers:
    result.append(str(num))
print(result)

# 2. map()
result = map(str, numbers)
print(list(result)) # map 함수 실행하려면, result 리스트를 출력하는 명령어 입력해야, 그때 map 함수가 실행함
```

- 예제: 리스트 일괄 3제곱하기
    - 파이썬 기본 함수에 없는 연산 해야 한다면: 함수 직접 만들어 map에 넣기

```python
# 1. for문
numbers = [1, 2, 3, 4, 5]

result = []
for number in numbers:
    result.append(number **3)
print(result)

# 2. map
def cube(x):
    return x ** 3

result = map(cube, numbers)
print(list(result))
```

- 예제

```python
test_input = '1 3 5 7 9'
# 띄어쓰기 기준으로 나누기
test_input.split()
    # .split(): 띄어쓰기 기준으로 단어 쪼개줌

# 각 글자를 숫자로 바꾸기
map(int, test_input.split())

# 리스트에 저장하기
result = list(map(int, test_input.split()))
print(result)
```

### filter

- `filter(함수, 시퀀스 데이터)`: 조건에 부합하는 것만 거름
    - filter에 넣는 함수: T/F 출력하는 함수만 넣을 수 있음
- 예제: 홀수만 고르기

```python
def is_odd(x): # T/F 나오는 함수 선언
    return x % 2

# 1. for문
numbers = [1,2,3,4,5,6]
result = []
for number in numbers:
    if number % 2 ==1:
        result.append(number)
print(result)

# 2. filter
result = filter(is_odd, numbers)
print(list(result))
```

### zip

- `zip(list1, list2)`: 2개 리스트를 같은 인덱스끼리 튜플로 묶어 압축
- 예제

```python
a = [1,2,3]
b = [100,200,300]

result = zip(a,b)
print(list(result))
```

---

# 9. 모듈

- 모듈화: py 파일에 함수 만듦 → 이를 다른 파일에서 가져와 함수 사용하는 것
- 모듈: 비슷 목적 코드들 묶어 놓은 것 → 개발 편리하게 하기 위해 활용
    - `import`: 외부에서 가져오는 명령어

```python
# fact.py 파일에서 모둘화
def factorial(n):
    if n == 1:
        return 1
    else:
        return factorial(n-1) * n
```

```python
# 다른 파일에서 모듈 활용
import fact
fact.factorial(5)
```

# 10. 패키지

- 패키지: 모듈을 묶어 놓은 것
    - 비슷한 역할의 코드끼리 묶어서 모듈화 >> 모듈은 패키지 폴더 내에 저장돼 있음
- 폴더 구조 잡기
    - init: 패키지명 입력 → 반드시 init 아니어도 됨
    - 변수/패키지 등 이름 구분 위해 >> `_` 대신 대소문자로 단어 구분
    - 폴더 구조 잡은 뒤 >> 모듈 넣어야 함

```python
# myPackage 폴더 생성
myPackage/
		__init__.py
		math/
				__init__.py
# 패키지 폴더 내 __init__.py 파일 존재 해야 패키지로 인식
```

- 패키지 불러오기: `from (어디에서 불러오는지) import (무엇을 불러올 것인지)`

```python
from myPackage.math.fomula import my_max
my_max(2, 3)

from myPackage.math import fomula
fomula.my_max(2, 3)

from myPackage.math.fomula import *
	# * fomula 모듈이 가진 모든 코드를 가져온다는 것
```

- 예시: 변수/파일명 동일할 경우
    - `as`: fomula 파일 이름을 f로 변경한 뒤 불러오기 위함

```python
fomula = 1234
# fomula 파일 이름을 f로 변경한 뒤 불러오기
from myPackage.math import fomula as f
print(fomula) # -> 변수 fomula
print(f) # -> 모듈 fomula 이름 f로 변경한 것
```

## 10.1 파이썬 내장 패키지

### math

- 일종의 계산기 → 수식 계산 가능
- `math.pi`: 파이값 도출해줌 → 소괄호 없으므로 함수X, 값임
- `math.e`: 자연상수 e값 도출
- `math.ceil(value)`: 소수점 올림 처리
- `math.floor(value)`: 소수점 내림 처리

```python
import math # math 함수 호출
math.e
> 2.718281828459045
math.ceil(math.e)
> 3
math.floor(math.e)
> 2
```

- `math.sqrt(value)`: 루트값 계산
- `math.factorial(value)`: 팩토리얼 계산
- 일반적 호출 방법: 한번에 필요한 모듈 가져오기

```python
from math import sqrt, factorial
sqrt(9)

> 3.0
factorial(5)
> 120
```

### random

- `random.random()`: 0~1 사이의 소수 랜덤으로 생성 → 실행할 때마다 숫자 달라짐
    - 구조: 모듈명.함수명( )
    - `random.randint`: 내가 지정한 범위 내에서 랜덤한 숫자 뽑음
    - 예제: 랜덤으로 자연수 뽑기

```python
import random
random.randint(1, 10)
```

- `random.seed(num)`: 랜덤하게 얻은 값을 고정하기
    - random 모듈 원리: 계산 통해 랜덤처럼 만듦 → 진짜 랜덤X, 계산값이기에 고정O

```python
random.seed(123) # 123 기준으로 계산했을 때 랜덤으로 얻은 값을 고정
random.random()
```

- `random.shuffle(list_name)`: 리스트 무작위로 섞어줌

```python
numbers = [1,2,3,4,5]
random.shuffle(numbers)
print(numbers)
```

- `random.choice(list_name)`: 리스트 중 하나를 무작위로 뽑음 → 복원 추출 방식
    - 복원 추출: 한번 뽑은 데이터 포함해서 다음에도 뽑음
- `random.sample(list_name, 갯수)`: 비복원 추출 방식로 뽑기
    - 비복원 추출: 한번 뽑은 데이터는 그 다음에 제외한 뒤 뽑음

```python
# 리스트 numbers의 데이터 중 2개를 비복원 추출
random.sample(numbers, 2)
```

### datetime

- `datetime.now()`: 현재 시간 출력 → 밀리 세컨드까지 출력
    - `datetime.today()`: 동일 기능
    - 24시로 보여줌 → ex. 1
    
    ```python
    from datetime import datetime
    datetime.now()
    ```
    
- `datetime.utcnow()`: 영국 그리니치 천문대 기준 시간 보여줌 → 한국 시간은 여기서 +9
- 예시:

```python
# 저장한 순간의 시간을 변수 now에 저장하기
now = datetime.now()
# now 변수의 각 요소에 접근 가능
now.year
```

- `print(now)`: 사람이 보기 변한 2025-02-18 방식으로 변경하기
- `now.strftime()`: 날짜 포맷 변경하기

```python
now.strftime('%Y년 %m월 %d일')
> '2025년 02월 18일'
```

- `timedelta(변화량)`: 변화량 수치화 → 시간 계산하도록 해줌
    - 예제: 크리스마스 시간 계산하기

```python
# 크리스마스로부터 3일 뒤는 며칠?
x_mas = datetime(2025, 12, 25)
from datetime import timedelta
future = timedelta(days = 3)
print(x_mas + future)

# 오늘로부터 크리스마스 얼마나 남았나?
x_mas - now
> days = 309
```

## 10.2 외부 라이브러리

### requests

cf) [requests]([https://requests.readthedocs.io/en/latest/](https://requests.readthedocs.io/en/latest/))

- 인간을 위해 HTTP 요청을 할 때 활용하는 모듈
    - HTTP: 코드로 이뤄진 HTML을 인간이 가시적으로 보기 좋은 화면으로 바꾼 것
        - 요청-응답 세트로 이뤄진 인간-컴퓨터 상호작용
        - ex. 네이버 UI: 검색창 실행 요청 → 서버가 응답해 화면 보여줌
    - 데이터 수집할 때, 내가 원하는 데이터의 코드를 추출해서 수집해 활용 가능
- `pip install requests`: requests 모듈 설치 명령어
- requests를 활용한 데이터 추출: 데이터 추출: list를 반복문으로 돌림 → dict 내 특정 key 얻어 데이터 추출
    - 예제: 네이버 검색창 코드 긁어오기
    
    ```python
    import requests
    
    # 개발자 모드 열었을 때 나오는 코드를 텍스트 덩어리로 가져와달란 것
    #requests 모듈이 가진 get 함수 실행 >> get(링크, payload dict 결합)
    r = requests.get('http://naver.com')
    
    print(r.text) # list + dict 혼합된 코드 텍스트 덩어리 출력
    print(r.url) # url 출력
    ```
    
- json 타입 데이터 → dict 데이터로 변환 필요
    - C / Java 등은 dict 형태를 json이라 명명 → 파이썬의 dict 형태로 변환해야 `[ ]` 접근 가능
    - `.json( )`: python의 dict과 비슷한 유형을 dict 형식으로 전환해주는 함수
    - 예시
    
    ```python
    r = requests.get('http://api.github.com/events')
    print(type(r.text)) # json: string 형태이므로 []로 특정 키 접근X
    print(r.json()['message']) # dict으로 전환해 [] 접근O
    ```
    

### api

- 프로그램 돌리기 위해, 코드로 프로그램 실행하기 위한 규격 → like, TV 쓰기 위해 리모컨 쓰듯
    - 인터페이스: 대상과 연결돼 있는 접점 → 나와 어플리케이션 사이의 접점 만들어주는 것

### url 구조

```python
https://www.dhlottery.co.kr/common.do
?
method=getLottoNumber
&
drwNo=1159
```

- 물음표 기준으로 분기 이뤄짐 → 앞뒤로 (key, value) 쌍 존재
    - 앞: 필수 주소  |  뒤: 선택적인 정보
- 검색창에 검색하기 = 주소창의 `query='  '`에 정보 입력해 이동하는 것과 동일
- 주소창도 (키=밸류)가 &로 연결돼 있는 일종의 dictionary

- 예제: 복권 당첨 번호
    - `r.json()`: python에서 활용 가능한 dict으로 변경해줌

```python
import requests
# 동행복권 주소 변수에 할당
lotto_url = 'https://www.dhlottery.co.kr/common.do'
payload = {'method': 'getLottoNumber', 'drwNo': 1159}

# 동행복권의 1159회가 담은 데이터 코드 가져오기
r = requests.get(lotto_url, params=payload)
# 1159회 링크 생성
print(r.url)
print(r.text)
# 근데 가져온 데이터가 제이슨 type임
# json type: str 형태라 dict 아님 >> []로 개별 key 접근X

# json >> dict으로 전환
print(r.json())
lotto_dict = r.json() # dict으로 전환해 []로 접근O
print(lotto_dict['drwNoDate'])

# 당첨 번호 출력
for i in range(1, 7): # 로또 번호 갯수 6개니까 범위 설정
    print(lotto_dict[f'drwtNo{i}'])
	    # drwtoNo라는 key에 1~6까지 숫자 i를 붙이려 string의 f로 연결
```

- api 문서에는 무얼 입력하면 어떤 값 얻을 수 있는지 규격 설명돼 있음 → 설명 확인 후 데이터 수집하기

## 10.3 실습

### 로또

1. 번호 생성 후, 당첨 결과 출력하기
    1. 로또 5천원 구매
    2. 랜덤으로 6개 숫자로 이뤄진 5개 세트의 로또 번호 생성
    3. 최신회차 당첨 번호와 생성된 번호 비교해 몇등인지 출력
- 로또 번호 5세트 생성

```python
import random
my_numbers = {}

# 1~45 중 6개 뽑아서 랜덤 번호 만든 뒤 random_numbers에 저장 * 5세트 하기
for i in range(1, 6): # 1~5회차 로또 세트 만들기
    random_numbers = random.sample(range(1, 46), 6) # 1~45 중 6개 뽑기 >> 변수에 저장
    # 효율화 위해, 5세트 번호를 my_number dict에 추가해 저장하기
    random_numbers.sort() # 가시적으로 보기 위해, 랜덤번호 오름차순 정렬
    
    # 각 회차 번호 적기: 번호 생성 과정 5회차 반복하는데,
		    # dict인 my_numbers에 i번째에 각 생성된 random_numbers 저장
    my_numbers[i] = random_numbers
print(my_numbers)
```

- 최신 회차 당첨 번호 수집

```python
import requests

# 1. 로또 주소 입력
LOTTO_URL = 'https://www.dhlottery.co.kr/common.do'
    # 파이썬에선 주로 상수를 대문자로 작성
payload = {
    'method': 'getLottoNumber',
    'drwNo': 1159}

res = requests.get(LOTTO_URL, params=payload) # res: requests의 짝꿍인 respones 의미
lotto_dict = (r.json()) # json을 dict로 변경

# 2. 보너스 번호 저장
bonus_number = lotto_dict['bnusNo']

# 3. 당첨번호 저장하기
lucky_numbers = []

# lotto_dict의 모든 데이터를 한번씩 조회 >> 이후 key 이름 drwtNo로 시작하는 것만 추출
for k, v in lotto_dict.items():
    if 'drwtNo' in k: # dict에 들어있는 key 이름에 해당 글자 포함돼 있는지
        lucky_numbers.append(v) # 그렇다면 lucky_number에 value를 추가
print(lucky_numbers)
```

- 등수 확인
    - `set` 활용하기: 내 번호, 당첨번호 사이의 교집합 계산해서 비교

```python
# 내 로또 dict 중 value만 반복하기
for my_number in my_numbers.values():

    # 집합 활용하기 위해, set로 형변환: list로는 집합X
    my_number_set = set(my_number)
    lucky_numbers_set = set(lucky_numbers)
    
    # 교집합 연산하기 >> 교집합의 갯수 확인 위해 len() 활용
    match_count = len(my_number_set & lucky_numbers_set)
    if match_count == 6:
        print('1등')

    # and: 왼/오 조건 모두 만족할 때 true 반환
    # my_number 안에 bonus_number 있는지 묻는 것
    elif match_count == 5 and bonus_number in my_number:
        print('2등')
    elif match_count == 5:
        print('3등')
    elif match_count == 4:
        print('4등')
    elif match_count == 3:
        print('5등')
    else:
        print('꽝')
```

---

# 11. Error

- 에러 발생하면 아래 문장 반드시 읽은 뒤 해결하기

### 11.1 Syntax error

- 문법적으로 코드 완료되지 않은 경우
    - `“`, `‘`, `:` 등 기호 누락 등

### 11.2 exception

- `ZeroDivisionError`: 수학적 관점에서 동작 할 수 없는 경우
    - ex. 5를 0으로 나누는 경우
- `NameError`: name space에서 해당 이름을 찾을 수 없는 경우
    - ex. 변수 선언되지 않았거나 or string을 따옴표 처리 하지 않은 경우
- `TypeError`
    - 연산자 쓰려고 하는데, 해당 연산자 적용 불가능한 데이터 타입 들어올 때
    - 함수 규격 맞추지 않은 경우: 인자 2개 넣어야 하는데, 적게 or 넘치게 넣을 때
- `ValueError`: 데이터 형변환 과정 중, 데이터 규격 다른 경우 → 입력값이 규격에 다름
- `IndexError`: 인덱스 범위 밖을 입력한 경우
- `KeyError`: dictonary 내 입력한 key 없는 경우
- `ModuleNotFoundError`
    - 아직 설치하지 않은 모듈 불러오라 한 경우
    - 가상 환경에 모듈 설치했는데, 활성화 안 한 경우
    - 모듈 이름 잘못 쓴 경우

## 11.3 예외 처리: try-except

- **구조**: `try` 코드 진행하다가 → 예외 발생 시, `except` 코드 진행

```python
try:
		code
except exception:
		code
```

- 오류 경우에 따라 except 별도로 설정 가능
    - 예시: 문자 입력 시 오류 & 0으로 나눌 시 오류 발생 → 오류 별로 달리 출력하기
    
    ```python
    try:
        num = int(input('100을 무엇으로 나누겠습니까?'))
        print(f'100을 {num}으로 나눈 값은 {100/num}입니다.')
    except ValueError: # 숫자를 입력하지 않은 경우
        print('입력한 데이터는 숫자가 아닙니다.')
    except ZeroDivisionError:
        print('모든 수는 0으로 나눌 수 없습니다')
    ```
    
- `else`: 에러 안 났을 때만 실행되는 코드
    - 예시
    
    ```python
    try:
        numbers = [1,2,3]
        numbers[1]
    except:
        print('오류')
    
    # try를 만나서 일단 코드 실행했고 >> 이후 except 만나지 않은 경우 실행되는 코드임
    else:
        print('여기는 else입니다')
    ```
    
- `finally`: 에러 나든 안 나든 무조건 실행되는 코드
    - 예시
    
    ```python
    try:
        numbers = [1,2,3]
        numbers[100]
    except:
        print('오류')
    finally:
        print('여기는 else입니다')
    ```
    

---

# 12. 객체지향 프로그래밍(OOP)

- object(객체): 일상 사물은 모두 객체임 → 각 객체는 데이터/기능 내포
    
    ex. 사람 객체: 성별, 나이, 이름 등 데이터 가짐
    
    걷기, 공부 등 동작 기능(function) 함
    
- 클래스(class): 같은 종류의 집단에 속하는 **속성**과 **행동**에 대한 정의
    - ex. cat 정의 → 만들려는 코드를 정의
        - 데이터: 다리 4개, 수염O → 정의 내부에 고양이의 속성인 데이터 넣음
        - 기능도 넣음: 그루밍 할 수 있음, 달릴 수 있음

→ 근데 고양이에 대한 정의일 뿐, 실제 고양이는X, 이렇게 데이터+기능 포함한 클래스 만듦

- 속성(attribute): 클래스/인스턴스가 가진 데이터/값
- 행동(method): 클래스/인스턴스가 가진 함수/기능
    - 객체 내부에 가진 함수를 method라고 부르는 것 → 함수인데 이름만 구분한 것
- 인스턴스(instance): 클래스를 실제로 메모리 상에 할당한 것

## 12.1 class

- 데이터 저장 + 함수로 계산하는 과정 자체를 묶는 것 → 일종의 정의임
- 구조
    - 클래스 선언/정의
        - 함수 선언 방식 유사 → 클래스명: 각 단어 시작점을 대문자로 구분해 표기
        - 데이터+함수를 class로 묶은 것 → 데이터/함수 무한히 넣을 수 있음
    
    ```python
    class ClassName():
    		# 변수 정의: 데이터/값/속성 넣는 공간
    		attribute1 = value1
    		attribute2 = value2
    		...
    		# 함수 만들기
    		def method_name1(self):
    				code
    		def method_nmae2(self):
    				code
    		...
    ```
    
    - 인스턴스화(클래스 실행)
    
    ```python
    c = ClassName()
    ```
    
- 예제:

```python
# 1. 선언
class MyClass():
    # kim이라는 데이터를 name 변수에 저장
    name = 'kim'
    # 함수 선언
    def hello(self):
        return 'hi-hi-hi'
        
# 2. 인스턴스
m = MyClass()
print(type(m))
# > <class '__main__.MyClass'> : 우리가 직접 만든 거라 main 붙은 것

print(m.name) # MyClass에 넣은 변수 name의 데이터에 접근하기
print(m.hello()) # hello라는 기능 만들어놨기에 >> 함수 실행하면, hi-hi-hi 출력
```

- 2개 변수에 각각 클래스 할당해 인스턴스화 2번 하면 → 2개의 독립적인 class 만들어짐
    - 인스턴스 내 데이터 수정해도 해당 인스턴스만 수정

```python
m2 = MyClass() # 또다른 인스턴스화
m2.name = 'park' # m2의 변수 name에 'park'이라는 다른 데이터 저장
# > m.name = 'kim', m2.name = 'park'으로 변경
```

- 예제: 핸드폰 만들기

```python
# 1. 핸드폰 정의 만들기
class Phone():
    # 1) 핸드폰 정의에 필요한 요소 넣기
    power = False # 폰 전원은 꺼져 있음
    number = '010-0000-0000' # 폰번호는 이러함
    book = {}
    model = ''

    # 2) 핸드폰 기능 만들기
    # 핸드폰 전원 꺼져 있으면 키기
    def on(self): # 클래스 안에 들어있는 메소드는 무조건 self 넣어야 함 >> self = 나/인스턴스 자신을 의미
        if self.power == False: # 값 비교 위해 == 사용
            self.power = True # 값 할당 위해 = 사용
    # 전원 켜져 있으면 끄기
    def off(self):
        if self.power == Talse:
            self.power = False
    # 전화 기능 추가하기
    def call(self, target): # self: 인스턴스 자기 자신 의미
        if self.power == True: # 전화기능 쓰기 위해선 전원 켜져 있어야 함 >> 조건문 분기처리

            # target.number라고 해야, 타겟의 number 변수에 저장된 데이터에 접근 가능
            print(f'{self.number}가 {target.number}한테 전화거는 중') # 내 폰으로 타인에게 전화 걸기 위해선, 거는 사람은 나 자신(self) + target이 가진 번호로 걸겠다는 코드
        else:
            print('핸드폰이 꺼져있습니다.')

2. 2개의 핸드폰 공장에서 찍어내기
my_phone = Phone()
your_phone = Phone()

my_phone.number # my_phone의 변수 number에 할당된 데이터에 접근하는 것

# 내 핸드폰 번호 변경하기
my_phone.number = '010-1111-1111'
print(my_phone.number)

my_phone.power # 현재 내 폰 꺼져 있는 상태
my_phone.on() # 전원 키기 기능 실행
my_phone.power # 이제 내 폰 켜져 있게 됨

your_phone.power # 내 폰만 켜져 있고, your_phone은 독립적 클래스니까 꺼져있음

my_phone.call(your_phone) # 함수 실행할 때, self는 입력 안 해도 됨
```

- 예제: 사람 정의하기
    - 사람 데이터 프레임 생성 → 이후 각 사람별 서로 다른 데이터 할당
    - 원리: Person 인스턴스한 결과가 p1에 저장
        
        → 기존 클래스인 Person이 아닌, 객체 p1이 가진 프레임 내 변수 name 값만 수정
        

```python
1. 클래스 생성

class Person():
    name = ''
    gender = ''
    age = 0
    height = 0
    
    # 인사하는 기능 넣기
    def greeting(self):
       print(f'안녕하세요. 저는 {self.name}입니다.')
	       # self X면, 가장 가까운 name 찾아 가리킴
			    # 그럼 클래스 Person의 값X는 name 가리킴
				    # 자기 인스턴스의 name 지칭 위해 >> self.name이라 작성
       
    # 내년 나이 출력하기
    def grow(self):
        self.age += 1
        return self.age # return 해야 연산 값 출력됨
								        # 틀린 코드 예) return self.age += 1 -> return 뒤에 += X

2. 인스턴스
p1 = Person()
p2 = Person()

p1.name = 'hong'
p2.name = 'kim'

p1.gender = 'F'
p2.gender = 'M'

p1.age = 20
p2.age = 30

p1.height = 40
p2.height = 50

# 기능 실행하기
print(p1.greeting())
print(p2.grow())
```

## 12.2생성자/소멸자

- 생성자: 생성할 때 동시에 실행돼 생성에 도움 주는 함수
    - `def __init__(value)`: 객체 생성과 동시에 속성 값 설정해줌
        
        클래스 생성 후 인스턴스 할 때(ex. `person1 = Person("홍길동")`) 자동으로 실행됨
        
        그러면 상위 클래스의 `self.name = name` 에서 <name → 홍길동>으로  초기화해 저장
        
        - `self.name = name`: ‘현재 객체의 name 속성’에 `name` 값을 덮어쓰기 저장
- 구조
    - 함수 이름은 고정값 → 해당 이름으로 지정해야 생성자로 활용 가능

```python
class MyClass():
		# 생성자
		def __init__(self):
				pass
		# 소멸자
		def __del__(self):
				pass
```

- 예제:
    - 사람 생성하기
    
    ```python
    # 1. 클래스 생성
    class Person():
        name = ''
        def __init__(self, name): # 클래스 Person에 저장된 변수 name 의미
        
            # self.name: 인스턴스 p1의 변수 name 의미
            self.name = name # self.name의 영역에 입력된 name 값을 할당
            print('생성됨')
    
    # 2. 인스턴스화
    p1 = Person('park') # = Person.__init__(self, name)와 동일한 코드임
    	# 원리: Person 클래스에 저장된 __init__함수 실행됨
    ```
    
    - 원의 둘레/면적 구하기
    
    ```python
    1. 클래스 만들기: 원 만들기 >> r: 반지름, (x,y): 중심점
    class Circle():
        pi = 3.14
        
        # 인스턴스할 때 동시에 r, x, y 3개의 값 저장하도록 하는 생성자
        def __init__(self, r, x=0, y=0):
    	    # x,y는 기본값 인자 (0,0)으로 설정 >> 값 1개(r값)만 사용자가 입력해도 작동O
    		    # 반지름 값만 출력하고 싶다면, 함수 선언할 때 기본값 인자 설정하면 됨
            self.r = r
            self.x = x
            self.y = y
    
        # 원의 정보 출력하는 함수 만들기
        def info(self):
            print(f'반지름: {self.r}, 중심점: {self.x}, {self.y}') # 자기 인스턴스 내에 저장된 r 값, (x,y) 값을 출력
    
        # 원의 면적 구하기
        def area(self):
            return self.r ** 2 * self.pi # 원마다 반지름 다르기에, 각 self.r로 쓴 것
            # ex. c1의 r, c1의 pi를 연산한단 것 >> 셀프는 일단 자신 안에 있는 파이 찾고 >> 없으면, 나를 생성한 정의로 올라타고 찾음
    
        # 원의 둘레 구하기
        def round(self):
            return self.r * self.pi * 2
    
        # 원의 좌표 이동하기
        def move(self, x, y): # 새 좌표 받아서 이동하겠다는 것
            self.x = x # 새로운 x로 덮어쓰기
            self.y = y
            
    2. 인스턴스
    # 3개의 원 정보 입력
    c1 = Circle(5, 0, 0)
    c3 = Circle(4)
    
    3. 출력
    # 각 원의 r, (x, y) 출력
    c1.info()
    > 반지름: 5, 중심점: 0, 0
    c3 = Circle(4) # (x, y) 기본값 인자 설정해서 >> 입력X면 (0, 0)으로 출력
    반지름: 4, 중심점: 0, 0
    
    # 원의 면적/둘레 구하기
    print(c1.area())
    print(c2.round())
    
    # 원의 좌표 이동하기
    c1.move(100,100)
    c1.info()
    > 반지름: 5, 중심점: 100, 100
    ```
    
- 데이터의 결과는 또 다른 객체임, 객체는 기능 갖고 있기에 이는 또 메소드를 실행할 수 있음 >> 데이터의 결과를 다시 이용하고 계속 타고 올라가는 식으로 코드 쭉 이어서 쓸 수 있는 것
    - 예시
        - pop( ): 해당 리스트의 가장 마지막 값을 제거한 뒤 반환
        - capitalize( ): 반환된 값인 c를 대문자로 변경
    
    ```python
    ['a', 'b', 'c'].pop().capitalize()
    > C
    ```
    
    - 예제: 2개의 클래스 연관해 사용하기
        - 클래스 목적: 비슷한 기능하는 코드/함수 등 묶어, 재사용성 높이기 위함
    
    ```python
    1. 클래스1: 점의 좌표
    1) 클래스 생성
    class Point():
        def __init__(self, x, y):
            self.x = x
            self.y = y
    
        def info(self):
            print(f'{self.x},{self.y}')
    
    2) 인스턴스: p1, p2에 클래스 Point 저장 >> 원의 좌표 데이터      
    p1 = Point(1,1)
    p1.info()
    > 1,1
    
    2. 클래스2: 원의 정보 출력
    1) 클래스 생성
    class Circle():
        def __init__(self, r, point):
            self.r = r
            self.point = point # 이때 point는 상위 클래스인 Point를 의미하는 게 아님, 사용자에게 입력받은 것을 저장하는 공간인 변수임 >> 근데 c1 = Circle(10, p1) 이라고 p1를 point 변수에 저장함 >> 그래서 출력 결과는 p1에 저장된 (1,1)이 출력되는 것
        # point라는 객체는 x,y라는 객체 가지고 있어, 개별 접근 가능
        def info(self):
            print(f'반지름: {self.r}, 중심점: {self.point.x}, {self.point.y}')
            # 중심점: self에 들어 있는, 객체 point에 들어 있는, 객체 x와 y에 접근하겠단 것 >> 그러면 앞서 Point 클래스에서 좌표 묶여 있던 것을 개별적으로 객체 풀어서 출력 가능
    
    2) 인스턴스
    c1 = Circle(10, p1) # 반지름 = 10, 중심점 좌표 = p1인 원
    c1.info()
    > 반지름: 10, 중심점: 1, 1
    ```
    

## 12.3 클래스 변수 / 인스턴스 변수

- **클래스 변수**: 클래스가 가진 변수 → 클래스 선언 블록  최상단에 위치
    
    **인스턴스 변수**: 인스턴스가 가진 변수 → 인스턴스 내부에서 생성한 변수
    
- 구조

```python
class MyClass():
		class_variable = '클래스 변수'
		def __init__(self):
				self.instance_varialbe = '인스턴스 변수'
```

- 예시

```python
class Person():
    name = 'hong'
    age = 10
    def __init__(self, name):
        self.name = name

p1 = Person('park') # name 인스턴스 만듦 >> 인스턴스 변수 생성
print(p1.name) # 인스턴스 변수 출력
print(p1.age) # age는 인스턴스 만들지X >> 상위 클래스로 이동 >> 클래스 변수 age 접근해 출력
```

### 클래스 메소드 / 인스턴스 메소드 / 스태틱 메소드

- 클래스 내, 데이터 저장 가능한 공간: 클래스 변수, 인스턴스 변수 → 2가지 있음
    - **클래스 메소드**: 클래스 변수 조작 시 사용
    - **인스턴스 메소드:** 인스턴스 변수 조작 시 사용 → 인스턴스 데이터 변경하고 싶을 때
    - **스태틱 메소드**: 클래스/인스턴스 변수 모두 사용 X을 때 사용
- 구조

```python
class MyClass():
		# 인스턴스 메소드: @ 붙이지X
		def instance_method(self): # self: 인스턴스 객체 자체 의미
				pass
		# 클래스 메소드: 클래스 변수 사용하고자 할 때 씀 
		@classmethod
		def class_method(cls): # cls: 클래스 객체 자체 의미
				pass
		# 스태틱 메소드
		@staticmethod
		def static_method():
				pass
```

## 12.4 상속

- 상위 클래스는 자기 기능을, 하위 클래스에게 물려줄 수 있음 → 상속
    - ex. 강아지 하위엔 여러 종의 정의가 존재 → 포메, 비숑, 푸들 모두 강아지의 기능 가졌듯
    - 부모가 가진 기능 그대로 가져오기 + 하위 클래스만의 기능도 추가할 수O
- 예제: 사람 기능 → 군인에게 상속하기
    - 상위 클래스 생성
    
    ```python
    class Person():
        indent = ''
        def __init__(self, name):
            self.name = name
        def greeting(self):
            print(f'안녕하세요. {self.name} 입니다.')
    
    p1 = Person('hong')
    p2 = Person('kim')
    p1.greeting()
    p2.greeting()
    ```
    
    - 하위 클래스 생성
        - 상위 클래스: Person,  하위 클래스: Soldier
    
    ```python
    1. 하위 클래스에 상속하기
    class Soldier(Person): # (): 상속을 하기 위한 공간
    		# Person이 가진 모든 정보를 Soldier에 상속됨 >> pass 외에 코드X어도 작동O
        def soldier_greeting(self):
    		    # 군인 인사법 달리 하고 싶을 때, 함수 추가하기
            print(f'충성 {self.name} 입니다.')
    
    2. 인스턴스
    s1 = Soldier('굳건이')
    s1.greeting() # 상위 클래스 Person의 인사법
    # > 안녕하세요. 굳건이 입니다.
    s1.soldier_greeting() # 하위 클래스 Soldier에서만 적용되는 인사법
        # 새로 추가한 함수 이름이 기존 함수와 이름 동일하다면, 새 함수가 우선 실행됨
    ```
    
- `super( )`: 부모가 가진 함수를 실행시키는 함수
    - 예제: 부모 클래스 + 변수 student_id 추가하고 싶다면?
    
    ```python
    1. 상위 클래스 생성
    class Person():
        def __init__(self, name, age, email, phone):
            self.name = name # self.name이라는 변수에 입력받은 name 값 저장
            self.age = age
            self.email = email
            self.phone = phone
    
    2. 하위 클래스 생성: 변수 studenft_id 추가하려면?
    class Student(Person):
        def __init__(self, name, age, email, phone, student_id):
            super().__init__(name, age, email, phone, student_id) # 부모의 init함수 실행
    			    # 상위 init 실행해 name, age, email, phone 받고, 위에 student_id 받기 위함
    	        
        # 상속되면, 부모 클래스 기능 자식이 사실상 갖고 있는데, 숨김처리된 것
        # def __init__(self, name, age, email, phone):
        #     self.name = name # self.name이라는 변수에 입력받은 name 값 저장
        #     self.age = age
        #     self.email = email
        #     self.phone = phone
    ```
    

### 다중 상속

- 여러 데이터로부터 상속 받는 경우 → 상위/부모 클래스가 여러 개인 경우
    - 예시
    
    ```python
    1. 최상위 클래스 Person: 숨 쉴 수 있음
    class Person():
        def __init__(self, name):
            self.name = name
        def breath(self):
            print('후하')
            
    2. 하위 클래스1 Mom: Person + swim 가능
    class Mom(Person):
        gender = 'XX'
        def swim(self):
            print('어푸어푸')
            
    3. 하위 클래스2 Dad: Person + run 가능
    class Dad(Person):
        gender = 'XY'
        def run(self):
            print('후두다닥')
            
    4. 최하위 클래스 Child: Mom + Dad + Person 기능 상속
    class Child(Mom, Dad):
        pass
        
    # 2개 클래스에게 상속받을 때 변수 겹치면, 먼저 상속받은 데이터를 얻음
    c.gender
    > 'XX' # Mom부터 상속받아서 XX 출력된 것
    ```